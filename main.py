# Список достопримечательностей с затратами времени и важностью
attractions = [
    ("Исаакиевский собор", 5, 10),
    ("Эрмитаж", 8, 11),
    ("Кунсткамера", 3.5, 4),
    ("Петропавловская крепость", 10, 7),
    ("Ленинградский зоопарк", 9, 15),
    ("Медный всадник", 1, 17),
    ("Казанский собор", 4, 3),
    ("Спас на Крови", 2, 9),
    ("Зимний дворец Петра I", 7, 12),
    ("Зоологический музей", 5.5, 6),
    ("Музей обороны и блокады Ленинграда", 2, 19),
    ("Русский музей", 5, 8),
    ("Навестить друзей", 12, 20),
    ("Музей восковых фигур", 2, 13),
    ("Литературно-мемориальный музей Ф.М. Достоевского", 4, 2),
    ("Екатерининский дворец", 1.5, 5),
    ("Петербургский музей кукол", 1, 14),
    ("Музей микроминиатюры «Русский Левша»", 3, 18),
    ("Всероссийский музей А.С. Пушкина и филиалы", 6, 1),
    ("Музей современного искусства Эрарта", 7, 16)
]

# Всего времени на посещение (32 часа)
total_time = 48-(2*8)


# Оптимизация с использованием метода динамического программирования
def optimize_route(attractions, total_time):
    n = len(attractions)
    # Создание таблицы для динамического программирования (DP)
    dp = [[0 for _ in range(int(total_time * 2) + 1)] for _ in range(n + 1)]

    # Заполняем таблицу
    for i in range(1, n + 1):
        for t in range(int(total_time * 2) + 1):
            time_required = int(attractions[i - 1][1] * 2)  # Время (в полчаса)
            importance = attractions[i - 1][2]  # Важность

            if time_required <= t:
                dp[i][t] = max(dp[i - 1][t], dp[i - 1][t - time_required] + importance)
            else:
                dp[i][t] = dp[i - 1][t]

    # Восстановление оптимального маршрута
    result = []
    t = int(total_time * 2)

    for i in range(n, 0, -1):
        if dp[i][t] != dp[i - 1][t]:
            result.append(attractions[i - 1])
            t -= int(attractions[i - 1][1] * 2)

    result.reverse()
    return result


# Получение оптимального маршрута
optimal_route = optimize_route(attractions, total_time)

# Вывод оптимального маршрута
for attraction in optimal_route:
    print(f"{attraction[0]}: {attraction[1]} ч, важность {attraction[2]}")
